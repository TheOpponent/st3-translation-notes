# This script reads a PNG file containing a single row of 48 x 32 screen images and
# outputs binary data for LC1 files.
# Pillow is required as a dependency.
#
# Specify input PNG files in the order generated by read_lc1.py. The output file name is
# formed from the name of the first input file and saved in the `output` subdirectory.
#
# The LC1 format is RLE-encoded image data with two values in each byte:
# The left nybble contains the run length up to 0xF, and the right nybble contains
# an intensity of 0, 7, 8, or F.
#
# The input PNG file should be an 8-bit image with no transparency and these four colors:
# 000000 707070 808080 F0F0F0
#
# The image will be quantized to the above palette.

import os
import struct
import sys
from itertools import groupby

from PIL import Image

path = os.path.join(os.path.realpath(os.path.dirname(sys.argv[0])))
output_path = os.path.join(path, "output")


def convert_screen_data(input_file):
    """Convert a 4-color PNG image into RLE-encoded binary data.
    Returns a tuple containing binary data, height, width,
    number of 00 bytes to insert as padding."""

    # Generate 4-color palette.
    palette = Image.new("P", (1, 1))
    palette.putpalette([0, 0, 0, 112, 112, 112, 128, 128, 128, 240, 240, 240])

    with Image.open(input_file) as image:
        output = b""

        image = image.convert("RGB").quantize(4, palette=palette)
        image_seq = list(image.getdata(0))
        image_size = image.size

        # Get RLE encoding.
        rle = [(len(list(g)), k) for k, g in groupby(image_seq)]

        for run_length, color in rle:
            if run_length == 0:
                continue

            if color == 1:
                color = 7
            elif color == 2:
                color = 8
            elif color == 3:
                color = 15

            if run_length > 15:
                repeat = divmod(run_length, 15)
                output += struct.pack("=B", 240 + color) * repeat[0]
                if repeat[1] > 0:
                    output += struct.pack("=B", (repeat[1] << 4) + color)
            else:
                output += struct.pack("=B", (run_length << 4) + color)

        if divmod(len(output), 4)[1] > 0:
            padding = 4 - divmod(len(output), 4)[1]
        else:
            padding = 0

    return (output, image_size[1], image_size[0], padding)


def make_lc1(input_files):
    table = b""
    image_data = b""
    converted_images = []

    for i in input_files:
        converted_images.append(convert_screen_data(i))

    table_length = len(input_files) * 20

    for i in converted_images:
        table += struct.pack("<I", table_length + len(image_data) + 16)
        table += struct.pack("<H", i[1])
        table += struct.pack("<H", i[2])
        table += struct.pack("<I", 1)
        table += struct.pack("<I", len(i[0]))
        table += b"\x00" * 4
        image_data += i[0]
        image_data += b"\x00" * i[3]

    output = (
        b"LCD1"
        + struct.pack("<I", table_length + len(image_data) + 16)
        + struct.pack("<I", 16)
        + struct.pack("<I", len(converted_images))
        + b"\x00\x00\x00\x00\x00\x00\x00\x00"
        + table
        + image_data
        + b"EOFC\x00\x00\x00\x00"
    )

    filename = os.path.join(
        output_path, os.path.split(sys.argv[1])[1].split(".")[0] + ".LC1"
    )
    with open(filename, "wb") as file:
        file.write(output)
        print(f"Wrote {len(sys.argv[1:])} image(s) to {os.path.abspath(filename)}.")


def main():
    if len(sys.argv) < 2:
        print("Specify input PNG files.")
        return

    else:
        make_lc1(sys.argv[1:])


if __name__ == "__main__":
    main()
