# This script reads a PNG file containing a single row of 48 x 32 screen images and
# outputs binary data for VMU screen output.
# NumPy and Pillow are required as dependencies.
#
# Specify an input PNG file and an optional output file as arguments.
# If an output file is not given, the binary data will be written in the console.
#
# The LCD graphic format generated by this script is 1 bit per pixel for low-level
# LCD screen write operations, rather than the standard 8 bits per pixel format.
# The screen is written to from top-left to bottom-right, one row at a time.
# 0 is off (white), 1 is on (black). 1 byte represents 8 horizontal pixels in
# little-endian order.
#
# The input image should be an 8-bit PNG file with no transparency.
# White pixels will be off and black pixels will be on. The input will be converted
# to 1-bit mode and inverted, so the black pixels in the input will be turned on in
# the LCD.

import struct
import sys

import numpy as np
from PIL import Image, ImageOps


def convert_screen_data(input_file):
    with Image.open(input_file) as input_file:
        output = b""

        # Read image as black and white, invert, and split into equal number of 48 x 32 arrays.
        image = input_file.convert("1")
        image = ImageOps.invert(image)
        image_seq = list(image.getdata(0))
        image_size = image.size
        image_2d = np.empty((image_size[1], image_size[0]), dtype="uint8")

        try:
            for i in range(0, 32):
                image_2d[i] = image_seq[i * image_size[0] : (i + 1) * image_size[0]]

            # Split into individual tiles.
            tiles = np.hsplit(image_2d, image_size[0] / 48)
            for tile in tiles:
                tile_output = b""
                for row in range(0, 32):
                    row_output = b""
                    for col in range(0, 6):
                        # Read each tile 8 pixels at a time.
                        byte = 0
                        for j in range(0, 8):
                            byte <<= 1
                            byte |= 1 if tile[row, (col * 8) + j] > 0 else 0
                        row_output += struct.pack("=B", byte)
                    tile_output += row_output
                output += tile_output

        except ValueError:
            print(
                "Input PNG file must be 8-bit, no transparency, and have a height of 32 pixels and width a multiple of 48 pixels."
            )
            return

        if len(sys.argv) >= 3:
            with open(sys.argv[2], "wb") as output_file:
                output_file.write(output)
                print(
                    f"Paste the contents of {sys.argv[2]} into a VMU screen data file starting at the tile(s) to replace."
                )

        else:
            print(output.hex())
            print(
                "\nPaste the above hex into a VMU screen data file starting at the tile(s) to replace."
            )


def main():
    if len(sys.argv) < 2:
        print("Specify input PNG file.")
        return

    else:
        convert_screen_data(sys.argv[1])


if __name__ == "__main__":
    main()
